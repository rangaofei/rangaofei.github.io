<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="DataBinding," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="Databinding 库这篇文档说明了这样使用DataBinding库来编写声明式布局并且精简应用程序逻辑和布局所需的粘性代码。 DataBinding库提供了灵活性和广泛的兼容性。它是一个支持库，你可以在安卓平台2.1(Api 7+)都可以使用这个库。 使用Databinding库要求安卓的gradle插件最低是1.5.0. 构建环境在安卓SDK管理工具中的支持库中下载DataBinding库">
<meta name="keywords" content="DataBinding">
<meta property="og:type" content="article">
<meta property="og:title" content="DataBinding(一)-初识">
<meta property="og:url" content="https://rangaofei.github.io/2017/02/01/DataBinding-一-初识/index.html">
<meta property="og:site_name" content="SAKA&#39;S BLOG">
<meta property="og:description" content="Databinding 库这篇文档说明了这样使用DataBinding库来编写声明式布局并且精简应用程序逻辑和布局所需的粘性代码。 DataBinding库提供了灵活性和广泛的兼容性。它是一个支持库，你可以在安卓平台2.1(Api 7+)都可以使用这个库。 使用Databinding库要求安卓的gradle插件最低是1.5.0. 构建环境在安卓SDK管理工具中的支持库中下载DataBinding库">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2017-02-04T00:56:52.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="DataBinding(一)-初识">
<meta name="twitter:description" content="Databinding 库这篇文档说明了这样使用DataBinding库来编写声明式布局并且精简应用程序逻辑和布局所需的粘性代码。 DataBinding库提供了灵活性和广泛的兼容性。它是一个支持库，你可以在安卓平台2.1(Api 7+)都可以使用这个库。 使用Databinding库要求安卓的gradle插件最低是1.5.0. 构建环境在安卓SDK管理工具中的支持库中下载DataBinding库">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://rangaofei.github.io/2017/02/01/DataBinding-一-初识/"/>





  <title> DataBinding(一)-初识 | SAKA'S BLOG </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  








  <div style="display: none;">
    <script src="https://s4.cnzz.com/z_stat.php?id=1261177704&web_id=1261177704" language="JavaScript"></script>
  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1261177704'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s4.cnzz.com/z_stat.php%3Fid%3D1261177704%26online%3D1%26show%3Dline' type='text/javascript'%3E%3C/script%3E"));</script>
  </div>





  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">SAKA'S BLOG</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle"></p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://rangaofei.github.io/2017/02/01/DataBinding-一-初识/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="rangaofei">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://ok7v12rvl.bkt.clouddn.com/01b18.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="SAKA'S BLOG">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="SAKA'S BLOG" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                DataBinding(一)-初识
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-01T21:02:10+08:00">
                2017-02-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">              
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/DataBinding/" itemprop="url" rel="index">
                    <span itemprop="name">DataBinding</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Databinding-库"><a href="#Databinding-库" class="headerlink" title="Databinding 库"></a>Databinding 库</h1><p>这篇文档说明了这样使用DataBinding库来编写声明式布局并且精简应用程序逻辑和布局所需的粘性代码。</p>
<p>DataBinding库提供了灵活性和广泛的兼容性。它是一个支持库，你可以在安卓平台2.1(Api 7+)都可以使用这个库。</p>
<p>使用Databinding库要求安卓的gradle插件最低是1.5.0.</p>
<h2 id="构建环境"><a href="#构建环境" class="headerlink" title="构建环境"></a>构建环境</h2><p>在安卓SDK管理工具中的支持库中下载DataBinding库来开始在你的项目中使用它。</p>
<p>在你app级别的build.gradle文件中加入DataBinding元素，来在你的应用重配置DataBinding。</p>
<p>代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ....</span><br><span class="line">    dataBinding &#123;</span><br><span class="line">        enabled = true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果你的应用中其他模块也使用了DataBinding库，你同样需要在对应的模块中的build.gradle中加入以上代码。</p>
<p>确保你的Android Studio版本在1.3之上。</p>
<h2 id="DataBinding的布局文件"><a href="#DataBinding的布局文件" class="headerlink" title="DataBinding的布局文件"></a>DataBinding的布局文件</h2><h3 id="编写你的第一个DataBinding表达式"><a href="#编写你的第一个DataBinding表达式" class="headerlink" title="编写你的第一个DataBinding表达式"></a>编写你的第一个DataBinding表达式</h3><p>DataBinding的布局文件和原来的布局稍有些不同，它的根布局是一个layout标签，里边包含一个data标签和原来的根布局。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">   &lt;data&gt;</span><br><span class="line">       &lt;variable name=&quot;user&quot; type=&quot;com.example.User&quot;/&gt;</span><br><span class="line">   &lt;/data&gt;</span><br><span class="line">   &lt;LinearLayout</span><br><span class="line">       android:orientation=&quot;vertical&quot;</span><br><span class="line">       android:layout_width=&quot;match_parent&quot;</span><br><span class="line">       android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line">       &lt;TextView android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">           android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">           android:text=&quot;@&#123;user.firstName&#125;&quot;/&gt;</span><br><span class="line">       &lt;TextView android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">           android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">           android:text=&quot;@&#123;user.lastName&#125;&quot;/&gt;</span><br><span class="line">   &lt;/LinearLayout&gt;</span><br><span class="line">&lt;/layout&gt;</span><br></pre></td></tr></table></figure>
<p>在data标签中的user变量在你的布局文件中使用。</p>
<p><code>&lt;variable name=&quot;user&quot; type=&quot;com.example.User&quot;/&gt;</code></p>
<p>布局文件中的表达式要写在属性中，并写成”@{}”形式。这个例子中，TextView中的文字被设置成为了user的firstName属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextView android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">          android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">          android:text=&quot;@&#123;user.firstName&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h3><p>让我们假设你有一个普通的java对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">   public final String firstName;</span><br><span class="line">   public final String lastName;</span><br><span class="line">   public User(String firstName, String lastName) &#123;</span><br><span class="line">       this.firstName = firstName;</span><br><span class="line">       this.lastName = lastName;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个对象中的数据不会改变。类似于这样的对象在java中非常常见并且可能被应用于JavaBean中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">   private final String firstName;</span><br><span class="line">   private final String lastName;</span><br><span class="line">   public User(String firstName, String lastName) &#123;</span><br><span class="line">       this.firstName = firstName;</span><br><span class="line">       this.lastName = lastName;</span><br><span class="line">   &#125;</span><br><span class="line">   public String getFirstName() &#123;</span><br><span class="line">       return this.firstName;</span><br><span class="line">   &#125;</span><br><span class="line">   public String getLastName() &#123;</span><br><span class="line">       return this.lastName;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从DataBinding的角度来看，这两个对象是相等的。在TextView属性中的android:text使用的表达式@{user.firstName}使用的是后者中的getFirstName方法。或者它也会被使用firstName()方法如果这个方法存在。</p>
<h3 id="绑定数据"><a href="#绑定数据" class="headerlink" title="绑定数据"></a>绑定数据</h3><p>通常情况下系统会生成一个Binding类，类的名称是根据你的布局文件后加上”Binding”。上边的布局文件名称是’main_activity.xml’，生成的类的名称是MainActivityBinding。（这里为了不引起误会我简单说一下，通常MainActivity生成的布局文件一般是activity_main.xml，则此时生的Biding类的名称应该是ActivityMainBinding）。这个类持有布局中所有属性的值（如user的firstName）并且知道如何通过表达式分发到各个控件。创建绑定控件的最简单的方式是在inflating的时候。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">   super.onCreate(savedInstanceState);</span><br><span class="line">   MainActivityBinding binding = DataBindingUtil.setContentView(this, R.layout.main_activity);</span><br><span class="line">   User user = new User(&quot;Test&quot;, &quot;User&quot;);</span><br><span class="line">   binding.setUser(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就完成了DataBinding的数据绑定，现在运行你应用程序就可以得到你设置的结果。你也可以这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MainActivityBinding binding = MainActivityBinding.inflate(getLayoutInflater());</span><br></pre></td></tr></table></figure>
<p>如果你正在ListView或者RecyclerView的Adapter中使用，你可以这样做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ListItemBinding binding = ListItemBinding.inflate(layoutInflater, viewGroup, false);</span><br><span class="line">//or</span><br><span class="line">ListItemBinding binding = DataBindingUtil.inflate(layoutInflater, R.layout.list_item, viewGroup, false);</span><br></pre></td></tr></table></figure>
<h3 id="传递事件"><a href="#传递事件" class="headerlink" title="传递事件"></a>传递事件</h3><p>DataBinding允许你为控件通过写表达式来传递事件，表达式必须是控件分发事件（例如 onClick）。 事件名称必须使用官方的监听方法的名称。 例如View.OnLongClickListener有一个方式是onLongClick()，所以这个事件的属性必须是：android：onLongClick.这里有两条途径来传递事件：</p>
<ul>
<li>方法引用：在你的表达式中你可以直接引用监听器的方法。当你引用方法时，DataBinding将会将引用方法和它所属的类包裹起来，并指定给目标控件。如果表达式的值为空，DataBinding不会创建方法并指定一个空的listener给控件。</li>
<li>监听绑定：使用lambda表达式来绑定事件。DataBinding也会创建一个监听器并指定给控件。当事件分发时，监听器会解析lambda表达式。</li>
</ul>
<h4 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h4><p>事件可以在直接用方法来传递。在Activity中也可以绑定类似于android:onClick方法，但是相对来说在布局文件中使用的好处就是可以在在编译的时候对表达式检查，如果有错误或者空指针会立即报错。</p>
<p>方法引用和监听器绑定的主要区别是，在实际运行的时候，监听器绑定在数据创建时绑定的，而不是在在事件触发时创建的。如果你喜欢在事件触发时创建，可以用监听器绑定的方法。</p>
<p>为了使事件正常分发，你的绑定表达式必须和所对应的回调方法有一样的参数。例如你的数据对象有两个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class MyHandlers &#123;</span><br><span class="line">    public void onClickFriend(View view) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>布局文件的表达式绑定：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">   &lt;data&gt;</span><br><span class="line">       &lt;variable name=&quot;handlers&quot; type=&quot;com.example.Handlers&quot;/&gt;</span><br><span class="line">       &lt;variable name=&quot;user&quot; type=&quot;com.example.User&quot;/&gt;</span><br><span class="line">   &lt;/data&gt;</span><br><span class="line">   &lt;LinearLayout</span><br><span class="line">       android:orientation=&quot;vertical&quot;</span><br><span class="line">       android:layout_width=&quot;match_parent&quot;</span><br><span class="line">       android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line">       &lt;TextView android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">           android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">           android:text=&quot;@&#123;user.firstName&#125;&quot;</span><br><span class="line">           android:onClick=&quot;@&#123;handlers::onClickFriend&#125;&quot;/&gt;</span><br><span class="line">   &lt;/LinearLayout&gt;</span><br><span class="line">&lt;/layout&gt;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>Note:方法的表达式必须和安卓系统的给定的表达式一致。</p>
</blockquote>
<h4 id="监听绑定"><a href="#监听绑定" class="headerlink" title="监听绑定"></a>监听绑定</h4><p>监听绑定是在事件触发时才进行绑定。和方法引用类似，但是它允许你在运行时传递任意参数。这个特性要求Android Gradle Plungin的gradle版本最低是2.0。</p>
<p>在方法引用中，传递的参数必须与安卓系统回调方法中的参数一致，但是在监听绑定中，你可以返回你所期望的值。例如，你可以有一个方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Presenter &#123;</span><br><span class="line">    public void onSaveClick(Task task)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后你可以在你的布局文件中绑定表达式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">  &lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">      &lt;data&gt;</span><br><span class="line">          &lt;variable name=&quot;task&quot; type=&quot;com.android.example.Task&quot; /&gt;</span><br><span class="line">          &lt;variable name=&quot;presenter&quot; type=&quot;com.android.example.Presenter&quot; /&gt;</span><br><span class="line">      &lt;/data&gt;</span><br><span class="line">      &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line">          &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">          android:onClick=&quot;@&#123;() -&gt; presenter.onSaveClick(task)&#125;&quot; /&gt;</span><br><span class="line">      &lt;/LinearLayout&gt;</span><br><span class="line">  &lt;/layout&gt;</span><br></pre></td></tr></table></figure></p>
<p>  监听器只允许作为表达式根元素的lambda表达式来表示。当在表达式中使用回调方法时，DataBinding自动为这个事件创建了一个监听器和寄存器。当控件触发时事件时，DataBinding会重新转换给定的表达式。在常规表达式中，当这些监听器表达式被转换时可能会得到空值和线程安全的DataBinding。</p>
<blockquote>
<p>Note:在上边的例子中，我们没有定义传递给onClick(android.view.view)的参数view。监听绑定可以有两个参数，你可以忽略他们或者全部给他们命名。如果你想要给全部参数命名，你可以在你的表达式中如下写：</p>
</blockquote>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:onClick=&quot;@&#123;(view) -&gt; presenter.onSaveClick(task)&#125;&quot;</span><br></pre></td></tr></table></figure>
<p>  你的数据对象中应该如下定义：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  public class Presenter &#123;</span><br><span class="line">    public void onSaveClick(View view, Task task)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:onClick=&quot;@&#123;(theView) -&gt; presenter.onSaveClick(theView, task)&#125;&quot;</span><br></pre></td></tr></table></figure>
<p>  你也可以使用lambda表达式来传递更多参数</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  public class Presenter &#123;</span><br><span class="line">    public void onCompletedChanged(Task task, boolean completed)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;CheckBox android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:onCheckedChanged=&quot;@&#123;(cb, isChecked) -&gt; presenter.completeChanged(task, isChecked)&#125;&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>如果你监听的事件返回一个非空的值，你的表达式必须返回相同的类型。例如你想要监听longCLick事件，你的表达式应该返回一个boolean值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Presenter &#123;</span><br><span class="line">    public boolean onLongClick(View view, Task task)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:onLongClick=&quot;@&#123;(theView) -&gt; presenter.onLongClick(theView, task)&#125;&quot;</span><br></pre></td></tr></table></figure>
<p> 假如由于空对象导致的表达式不能被转换，DataBinding会返回对应的默认的类型。例如0对于int，false对于boolean，null对于引用类型。</p>
<h4 id="避免使用复杂的监听器"><a href="#避免使用复杂的监听器" class="headerlink" title="避免使用复杂的监听器"></a>避免使用复杂的监听器</h4><p> 监听器表达式非常强大，可以是你的代码可读性更好。另一方面，包含复杂表达式的监听器让你的布局文件难以阅读和理解。这些表达式从UI传递到回调方法中的参数应该越简单越好。你应该在监听器的表达式调用方法中实现所有的业务逻辑</p>
<p>一些特定的点击事件已经存在并且需要android:onClick来避免冲突。下列属性已经被创建来避免冲突：</p>
<table>
<thead>
<tr>
<th>Class</th>
<th>Listener Setter</th>
<th>Attribute</th>
</tr>
</thead>
<tbody>
<tr>
<td>SearchView</td>
<td>setOnSearchClickListener(View.OnClickListener)</td>
<td>android:onSearchClick</td>
</tr>
<tr>
<td>ZoomControls</td>
<td>setOnZoomInClickListener(View.OnClickListener)</td>
<td>android:onZoomIn</td>
</tr>
<tr>
<td>ZoomControls</td>
<td>setOnZoomOutClickListener(View.OnClickListener)</td>
<td>android:onZoomOut</td>
</tr>
</tbody>
</table>
<h2 id="布局细节"><a href="#布局细节" class="headerlink" title="布局细节"></a>布局细节</h2><p>import元素在data标签中使用，这样可以让你像在java代码中导入你的类文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;data&gt;</span><br><span class="line">    &lt;import type=&quot;android.view.View&quot;/&gt;</span><br><span class="line">&lt;/data&gt;</span><br></pre></td></tr></table></figure>
<p>现在你可以在你的表达式中使用View了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextView</span><br><span class="line">   android:text=&quot;@&#123;user.lastName&#125;&quot;</span><br><span class="line">   android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">   android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">   android:visibility=&quot;@&#123;user.isAdult ? View.VISIBLE : View.GONE&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p> 当存在类的名称冲突时，可以使用别名来解决：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> &lt;import type=&quot;android.view.View&quot;/&gt;</span><br><span class="line">&lt;import type=&quot;com.example.real.estate.View&quot;</span><br><span class="line">        alias=&quot;Vista&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>现在在布局文件中你就可以使用Vista来表示com.example.real.estate.View，用View来表示android.view.View.在变量和表达式中也可以使用导入的类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;data&gt;</span><br><span class="line">    &lt;import type=&quot;com.example.User&quot;/&gt;</span><br><span class="line">    &lt;import type=&quot;java.util.List&quot;/&gt;</span><br><span class="line">    &lt;variable name=&quot;user&quot; type=&quot;User&quot;/&gt;</span><br><span class="line">    &lt;variable name=&quot;userList&quot; type=&quot;List&amp;lt;User&amp;gt;&quot;/&gt;</span><br><span class="line">&lt;/data&gt;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>Note:AndroidStudio目前还不支持为DataBinding的自动补全。但是你的应用还是会正常工作。你也可以使用完整的包名。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextView</span><br><span class="line">   android:text=&quot;@&#123;((User)(user.connection)).lastName&#125;&quot;</span><br><span class="line">   android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">   android:layout_height=&quot;wrap_content&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>导入的类型也可以加载静态方法或者表达式中的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;data&gt;</span><br><span class="line">    &lt;import type=&quot;com.example.MyStringUtils&quot;/&gt;</span><br><span class="line">    &lt;variable name=&quot;user&quot; type=&quot;com.example.User&quot;/&gt;</span><br><span class="line">&lt;/data&gt;</span><br><span class="line">…</span><br><span class="line">&lt;TextView</span><br><span class="line">   android:text=&quot;@&#123;MyStringUtils.capitalize(user.lastName)&#125;&quot;</span><br><span class="line">   android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">   android:layout_height=&quot;wrap_content&quot;/&gt;</span><br></pre></td></tr></table></figure></p>
<p>  就像Java中的import方法。</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>  在data标签种可以使用任意数量的variable元素。在布局文件中每一个variable元素都描述了一个在binding表达式中的属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;data&gt;</span><br><span class="line">    &lt;import type=&quot;android.graphics.drawable.Drawable&quot;/&gt;</span><br><span class="line">    &lt;variable name=&quot;user&quot;  type=&quot;com.example.User&quot;/&gt;</span><br><span class="line">    &lt;variable name=&quot;image&quot; type=&quot;Drawable&quot;/&gt;</span><br><span class="line">    &lt;variable name=&quot;note&quot;  type=&quot;String&quot;/&gt;</span><br><span class="line">&lt;/data&gt;</span><br></pre></td></tr></table></figure>
<p>变量类型是在编译的时候进行检查的，如果一个变量继承了Obserable或者是一个Obserable集合，应该在类型上反应出来。假如变量是一个没有继承Obserable的基础类或者接口，这个变量将不会被观察。</p>
<p>当有不同的布局文件配置时（例如landscape和portrati），这些变量将会合并。不允许出现可能会产生冲突的变量定义。</p>
<p>生成的binding类将会为每一个variable生成一个getter和setter方法，在文件未调用setter方法时，variable将会使用默认值–<br>null对于引用类型，0对于int，false对于boolean。</p>
<p> 一个叫做context的特殊变量会生成，用于绑定表达式中。contex的值是根view的getContext()，context将会被同样名字的显示变量覆盖。</p>
<h3 id="自定义绑定类的名称"><a href="#自定义绑定类的名称" class="headerlink" title="自定义绑定类的名称"></a>自定义绑定类的名称</h3><p> 默认情况下Binding类的名字是根据布局文件生成的，首写字母大写，下划线(_)去除，并将紧随其后的第一个字母大写然后加上Biding。这个类在module下的databinding包里边。例如，布局文件的名称是contact_item.xml，则生成的binding类的名称是ContactItemBinding,假如包的名称是com.example.my.app，则生成的类所在的位置是com.example.my.app.databinding.</p>
<p>Bindding类可以通过使用属性来重命名或者放在指定位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;data class=&quot;ContactItem&quot;&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/data&gt;</span><br></pre></td></tr></table></figure>
<p>上面一段代码在包中生成的binding类的名称是ContactItem。如果想在其他的包中生成这个类可以加上前缀”.”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;data class=&quot;com.example.ContactItem&quot;&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/data&gt;</span><br></pre></td></tr></table></figure>
<h4 id="Includes标签"><a href="#Includes标签" class="headerlink" title="Includes标签"></a>Includes标签</h4><p>Variables可以通过应用的命名空间和variable名字属性从布局文件传递给include布局中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">        xmlns:bind=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;</span><br><span class="line">   &lt;data&gt;</span><br><span class="line">       &lt;variable name=&quot;user&quot; type=&quot;com.example.User&quot;/&gt;</span><br><span class="line">   &lt;/data&gt;</span><br><span class="line">   &lt;LinearLayout</span><br><span class="line">       android:orientation=&quot;vertical&quot;</span><br><span class="line">       android:layout_width=&quot;match_parent&quot;</span><br><span class="line">       android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line">       &lt;include layout=&quot;@layout/name&quot;</span><br><span class="line">           bind:user=&quot;@&#123;user&#125;&quot;/&gt;</span><br><span class="line">       &lt;include layout=&quot;@layout/contact&quot;</span><br><span class="line">           bind:user=&quot;@&#123;user&#125;&quot;/&gt;</span><br><span class="line">   &lt;/LinearLayout&gt;</span><br><span class="line">&lt;/layout&gt;</span><br></pre></td></tr></table></figure>
<p>同样的，在include布局中应该有一样的vardable。</p>
<p>DataBinding不支持直接包含一个merage的布局，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">        xmlns:bind=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;</span><br><span class="line">   &lt;data&gt;</span><br><span class="line">       &lt;variable name=&quot;user&quot; type=&quot;com.example.User&quot;/&gt;</span><br><span class="line">   &lt;/data&gt;</span><br><span class="line">   &lt;merge&gt;</span><br><span class="line">       &lt;include layout=&quot;@layout/name&quot;</span><br><span class="line">           bind:user=&quot;@&#123;user&#125;&quot;/&gt;</span><br><span class="line">       &lt;include layout=&quot;@layout/contact&quot;</span><br><span class="line">           bind:user=&quot;@&#123;user&#125;&quot;/&gt;</span><br><span class="line">   &lt;/merge&gt;</span><br><span class="line">&lt;/layout&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="表达式语言"><a href="#表达式语言" class="headerlink" title="表达式语言"></a>表达式语言</h3><h4 id="常用特性"><a href="#常用特性" class="headerlink" title="常用特性"></a>常用特性</h4><p>表达式语言和java语法很相似。以下是相同的：</p>
<ul>
<li>Mathematical： + - / * %</li>
<li>String concatenation +</li>
<li>Logical &amp;&amp; ||</li>
<li>Binary &amp; | ^</li>
<li>Unary + - ! ~</li>
<li>Shift &gt;&gt; &gt;&gt;&gt; &lt;&lt;</li>
<li>Comparison == &gt; &lt; &gt;= &lt;=</li>
<li>instanceof</li>
<li>Grouping ()</li>
<li>Literals - character, String, numeric, null</li>
<li>Cast</li>
<li>Method calls</li>
<li>Field access</li>
<li>Array access []</li>
<li>Ternary operator ?:</li>
</ul>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">android:text=&quot;@&#123;String.valueOf(index + 1)&#125;&quot;</span><br><span class="line">android:visibility=&quot;@&#123;age &lt; 13 ? View.GONE : View.VISIBLE&#125;&quot;</span><br><span class="line">android:transitionName=&apos;@&#123;&quot;image_&quot; + id&#125;&apos;</span><br></pre></td></tr></table></figure></p>
<h4 id="不支持的操作"><a href="#不支持的操作" class="headerlink" title="不支持的操作"></a>不支持的操作</h4><p>java中的一些特性在DataBinding语法中不支持</p>
<ul>
<li>this</li>
<li>super</li>
<li>new</li>
<li>Explicit generic invocation</li>
</ul>
<h4 id="空合并运算-Null-Coalescing-Operator-—不知道怎么翻译"><a href="#空合并运算-Null-Coalescing-Operator-—不知道怎么翻译" class="headerlink" title="空合并运算(Null Coalescing Operator)—不知道怎么翻译"></a>空合并运算(Null Coalescing Operator)—不知道怎么翻译</h4><p>空合并运算(??)后边跟两个值，假如左边的值不为空会取左边的值，左边的值为空就去右边的值。</p>
<p><code>android:text=&quot;@{user.displayName ?? user.lastName}&quot;</code></p>
<p>等于下面的表达式</p>
<p><code>android:text=&quot;@{user.displayName != null ? user.displayName : user.lastName}&quot;</code></p>
<h4 id="属性引用"><a href="#属性引用" class="headerlink" title="属性引用"></a>属性引用</h4><p>前文中提到过，使用的是类中的getter方法或者是Observable域。<br><code>android:text=&quot;@{user.lastName}&quot;</code></p>
<h4 id="避免空指针异常"><a href="#避免空指针异常" class="headerlink" title="避免空指针异常"></a>避免空指针异常</h4><p>生成的DataBinding类会自动检查代码中的空对象并避免空指针异常。例如，表达式中@{user.name},假如user是空对象user.name将会是默认的值null。假如你在使用user.age，而这个age是一个int型，则会自动重置为0.</p>
<h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>常用的集合类型: arrays, lists, sparse lists,和maps, 可以通过简单的使用[]来表示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;data&gt;</span><br><span class="line">    &lt;import type=&quot;android.util.SparseArray&quot;/&gt;</span><br><span class="line">    &lt;import type=&quot;java.util.Map&quot;/&gt;</span><br><span class="line">    &lt;import type=&quot;java.util.List&quot;/&gt;</span><br><span class="line">    &lt;variable name=&quot;list&quot; type=&quot;List&amp;lt;String&amp;gt;&quot;/&gt;</span><br><span class="line">    &lt;variable name=&quot;sparse&quot; type=&quot;SparseArray&amp;lt;String&amp;gt;&quot;/&gt;</span><br><span class="line">    &lt;variable name=&quot;map&quot; type=&quot;Map&amp;lt;String, String&amp;gt;&quot;/&gt;</span><br><span class="line">    &lt;variable name=&quot;index&quot; type=&quot;int&quot;/&gt;</span><br><span class="line">    &lt;variable name=&quot;key&quot; type=&quot;String&quot;/&gt;</span><br><span class="line">&lt;/data&gt;</span><br><span class="line">…</span><br><span class="line">android:text=&quot;@&#123;list[index]&#125;&quot;</span><br><span class="line">…</span><br><span class="line">android:text=&quot;@&#123;sparse[index]&#125;&quot;</span><br><span class="line">…</span><br><span class="line">android:text=&quot;@&#123;map[key]&#125;&quot;</span><br></pre></td></tr></table></figure>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>可以在属性值使用单引号，在表达式中字符串的值使用双引号：<br><code>android:text=&#39;@{map[&quot;firstName&quot;]}&#39;</code></p>
<p>也可以在属性值使用双引号，表达式中的值字符串的值应该使用单引号或者是”`”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">android:text=&quot;@&#123;map[`firstName`&#125;&quot;</span><br><span class="line">android:text=&quot;@&#123;map[&apos;firstName&apos;]&#125;&quot;</span><br></pre></td></tr></table></figure>
<h4 id="资源文件"><a href="#资源文件" class="headerlink" title="资源文件"></a>资源文件</h4><p>在属性的表达式中也可以使用正常的资源引用方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:padding=&quot;@&#123;large? @dimen/largePadding : @dimen/smallPadding&#125;&quot;</span><br></pre></td></tr></table></figure>
<p>格式字符串和复数可以通过提供参数来完成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">android:text=&quot;@&#123;@string/nameFormat(firstName, lastName)&#125;&quot;</span><br><span class="line">android:text=&quot;@&#123;@plurals/banana(bananaCount)&#125;&quot;</span><br></pre></td></tr></table></figure>
<p>当复数有多个参数时，必须传递所有的参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Have an orange</span><br><span class="line">  Have %d oranges</span><br><span class="line"></span><br><span class="line">android:text=&quot;@&#123;@plurals/orange(orangeCount, orangeCount)&#125;&quot;</span><br></pre></td></tr></table></figure>
<p>一些资源文件必须通过显示声明：</p>
<p>类型|正常引用|表达式中引用<br>|—|—|—<br>|String[]|@array|@stringArray<br>|int[]|@array|@intArray<br>|TypedArray|@array|@typedArray<br>|Animator|@animator|@animator<br>|StateListAnimator|@animator|@stateListAnimator<br>|color int|@color|@color<br>|ColorStateList|@color|@colorStateList</p>
<h2 id="数据对象-1"><a href="#数据对象-1" class="headerlink" title="数据对象"></a>数据对象</h2><p>在DataBinding中可以使用任意的java对象，但是这些对象改变时不会引起UI的改变。DataBInding的强大之处正是可以赋予使你的数据对象通知UI改变的能力。有三种不同的数据改变通知机制：Observable objects, observable fields, 和observable collections.</p>
<p>当在UI和属性中使用了上面三种的一种时，UI会自动更新数据。</p>
<p>Obserable接口有一个自动添加和移除监听器的机制，但是通知数据更新取决于开发者。为了使开发变得简单，谷歌创建了BaseObserable这个基础类来集成监听器注册机制。通过给getter方法添加Bindable注解，通知setter方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private static class User extends BaseObservable &#123;</span><br><span class="line">   private String firstName;</span><br><span class="line">   private String lastName;</span><br><span class="line">   @Bindable</span><br><span class="line">   public String getFirstName() &#123;</span><br><span class="line">       return this.firstName;</span><br><span class="line">   &#125;</span><br><span class="line">   @Bindable</span><br><span class="line">   public String getLastName() &#123;</span><br><span class="line">       return this.lastName;</span><br><span class="line">   &#125;</span><br><span class="line">   public void setFirstName(String firstName) &#123;</span><br><span class="line">       this.firstName = firstName;</span><br><span class="line">       notifyPropertyChanged(BR.firstName);</span><br><span class="line">   &#125;</span><br><span class="line">   public void setLastName(String lastName) &#123;</span><br><span class="line">       this.lastName = lastName;</span><br><span class="line">       notifyPropertyChanged(BR.lastName);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在编译的时候这个Bindable注解会在BR.class中生成一个实体，这个BR.class会在包中生成。如果数据对象的基类不能被改变，则Observable接口可以使用简单的PropertyChangeRegistry来实现，以有效地存储数据和通知监听器。</p>
<h3 id="ObservableFields"><a href="#ObservableFields" class="headerlink" title="ObservableFields"></a>ObservableFields</h3><p>创建Observable类会稍微有一点麻烦，所以如果开发者想要节省时间可以使用ObservableField和它的同代-bservableBoolean, ObservableByte, ObservableChar, ObservableShort, ObservableInt, ObservableLong, ObservableFloat, ObservableDouble, 和 ObservableParcelable。ObservableFields拥有一个自己的额Observable域，避免在访问操作期间装箱拆箱。在使用时请在类中创建一个public final域。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private static class User &#123;</span><br><span class="line">   public final ObservableField&lt;String&gt; firstName =</span><br><span class="line">       new ObservableField&lt;&gt;();</span><br><span class="line">   public final ObservableField&lt;String&gt; lastName =</span><br><span class="line">       new ObservableField&lt;&gt;();</span><br><span class="line">   public final ObservableInt age = new ObservableInt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以使用get和set方法来改变值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user.firstName.set(&quot;Google&quot;);</span><br><span class="line">int age = user.age.get();</span><br></pre></td></tr></table></figure>
<h3 id="Observable-Collections"><a href="#Observable-Collections" class="headerlink" title="Observable Collections"></a>Observable Collections</h3><p>在一些应用中会使用动态结构来持有数据。Observable collections 允许通过键来访问对应的值。ObservableArrayMap键是字符串类型时非常有用，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ObservableArrayMap&lt;String, Object&gt; user = new ObservableArrayMap&lt;&gt;();</span><br><span class="line">user.put(&quot;firstName&quot;, &quot;Google&quot;);</span><br><span class="line">user.put(&quot;lastName&quot;, &quot;Inc.&quot;);</span><br><span class="line">user.put(&quot;age&quot;, 17);</span><br></pre></td></tr></table></figure></p>
<p>在布局文件中，通过字符串的key可以获得值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;data&gt;</span><br><span class="line">    &lt;import type=&quot;android.databinding.ObservableMap&quot;/&gt;</span><br><span class="line">    &lt;variable name=&quot;user&quot; type=&quot;ObservableMap&amp;lt;String, Object&amp;gt;&quot;/&gt;</span><br><span class="line">&lt;/data&gt;</span><br><span class="line">…</span><br><span class="line">&lt;TextView</span><br><span class="line">   android:text=&apos;@&#123;user[&quot;lastName&quot;]&#125;&apos;</span><br><span class="line">   android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">   android:layout_height=&quot;wrap_content&quot;/&gt;</span><br><span class="line">&lt;TextView</span><br><span class="line">   android:text=&apos;@&#123;String.valueOf(1 + (Integer)user[&quot;age&quot;])&#125;&apos;</span><br><span class="line">   android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">   android:layout_height=&quot;wrap_content&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>ObservableArrayList在键是int类型时非常有用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ObservableArrayList&lt;Object&gt; user = new ObservableArrayList&lt;&gt;();</span><br><span class="line">user.add(&quot;Google&quot;);</span><br><span class="line">user.add(&quot;Inc.&quot;);</span><br><span class="line">user.add(17);</span><br></pre></td></tr></table></figure>
<p>在布局文件中可以通过索引来获取值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;data&gt;</span><br><span class="line">    &lt;import type=&quot;android.databinding.ObservableList&quot;/&gt;</span><br><span class="line">    &lt;import type=&quot;com.example.my.app.Fields&quot;/&gt;</span><br><span class="line">    &lt;variable name=&quot;user&quot; type=&quot;ObservableList&amp;lt;Object&amp;gt;&quot;/&gt;</span><br><span class="line">&lt;/data&gt;</span><br><span class="line">…</span><br><span class="line">&lt;TextView</span><br><span class="line">   android:text=&apos;@&#123;user[Fields.LAST_NAME]&#125;&apos;</span><br><span class="line">   android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">   android:layout_height=&quot;wrap_content&quot;/&gt;</span><br><span class="line">&lt;TextView</span><br><span class="line">   android:text=&apos;@&#123;String.valueOf(1 + (Integer)user[Fields.AGE])&#125;&apos;</span><br><span class="line">   android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">   android:layout_height=&quot;wrap_content&quot;/&gt;</span><br></pre></td></tr></table></figure>
<h2 id="创建绑定文件"><a href="#创建绑定文件" class="headerlink" title="创建绑定文件"></a>创建绑定文件</h2><p>生成的Binding类将布局文件中的variable与视图关联起来，像前边说的，Binding类的名称可以自定义，生成的Binding类继承了ViewDataBiding。</p>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>应在inflation后立即创建绑定，以确保在使用布局中的表达式绑定到视图之前，View层次结构不受干扰。 有几种方法绑定到布局。 最常见的是在Binding类上使用静态方法。inflate方法扩充了View层次结构并且绑定到它所有一步。 有一个更简单的版本，只需要一个LayoutInflater和一个还需要一个ViewGroup：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyLayoutBinding binding = MyLayoutBinding.inflate(layoutInflater);</span><br><span class="line">MyLayoutBinding binding = MyLayoutBinding.inflate(layoutInflater, viewGroup, false);</span><br></pre></td></tr></table></figure>
<p>如果布局文件使用一种不同的机制，可以单独绑定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyLayoutBinding binding = MyLayoutBinding.bind(viewRoot);</span><br></pre></td></tr></table></figure>
<p>有时，binging类不能提前知道。 在这种情况下，可以使用DataBindingUtil类创建绑定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ViewDataBinding binding = DataBindingUtil.inflate(LayoutInflater, layoutId,</span><br><span class="line">    parent, attachToParent);</span><br><span class="line">ViewDataBinding binding = DataBindingUtil.bindTo(viewRoot, layoutId);</span><br></pre></td></tr></table></figure>
<h3 id="带Id的Views"><a href="#带Id的Views" class="headerlink" title="带Id的Views"></a>带Id的Views</h3><p>在布局文件中带Id的View会创建出一块public final域，绑定在View层次结构上执行单次传递，从而使用ID提取视图。 这个机制可能比为几个视图调用findViewById更快。 例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">   &lt;data&gt;</span><br><span class="line">       &lt;variable name=&quot;user&quot; type=&quot;com.example.User&quot;/&gt;</span><br><span class="line">   &lt;/data&gt;</span><br><span class="line">   &lt;LinearLayout</span><br><span class="line">       android:orientation=&quot;vertical&quot;</span><br><span class="line">       android:layout_width=&quot;match_parent&quot;</span><br><span class="line">       android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line">       &lt;TextView android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">           android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">           android:text=&quot;@&#123;user.firstName&#125;&quot;</span><br><span class="line">   android:id=&quot;@+id/firstName&quot;/&gt;</span><br><span class="line">       &lt;TextView android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">           android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">           android:text=&quot;@&#123;user.lastName&#125;&quot;</span><br><span class="line">  android:id=&quot;@+id/lastName&quot;/&gt;</span><br><span class="line">   &lt;/LinearLayout&gt;</span><br><span class="line">&lt;/layout&gt;</span><br></pre></td></tr></table></figure></p>
<p>生成一个binding类包含以下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public final TextView firstName;</span><br><span class="line">public final TextView lastName;</span><br></pre></td></tr></table></figure></p>
<p>Id在数据绑定中几乎不会使用，但是仍然有一些情况下需要通过id获取视图。</p>
<h3 id="变量-1"><a href="#变量-1" class="headerlink" title="变量"></a>变量</h3><p>每一个变量都应该有访问方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;data&gt;</span><br><span class="line">    &lt;import type=&quot;android.graphics.drawable.Drawable&quot;/&gt;</span><br><span class="line">    &lt;variable name=&quot;user&quot;  type=&quot;com.example.User&quot;/&gt;</span><br><span class="line">    &lt;variable name=&quot;image&quot; type=&quot;Drawable&quot;/&gt;</span><br><span class="line">    &lt;variable name=&quot;note&quot;  type=&quot;String&quot;/&gt;</span><br><span class="line">&lt;/data&gt;</span><br></pre></td></tr></table></figure></p>
<p>在绑定时自动生成了getter和setter方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public abstract com.example.User getUser();</span><br><span class="line">public abstract void setUser(com.example.User user);</span><br><span class="line">public abstract Drawable getImage();</span><br><span class="line">public abstract void setImage(Drawable image);</span><br><span class="line">public abstract String getNote();</span><br><span class="line">public abstract void setNote(String note);</span><br></pre></td></tr></table></figure></p>
<h3 id="ViewStubs（这篇不常用，-而且文档介绍较少）"><a href="#ViewStubs（这篇不常用，-而且文档介绍较少）" class="headerlink" title="ViewStubs（这篇不常用， 而且文档介绍较少）"></a>ViewStubs（这篇不常用， 而且文档介绍较少）</h3><p>ViewStub和普通的view 有一些区别，开始的时候它们是不可见的，知道被设置为可见或者inflate，它们会将自己替换为另个一个指定的布局。</p>
<p>因为ViewStub基本上再View层次结构中不可见，所以绑定对象中的View也必须消失以允许收集。 因为View是final的，所以ViewStubProxy对象代替ViewStub，当ViewStub存在时允许开发人员访问ViewStub，当ViewStub替换后，还可以访问替换后的的View层次。</p>
<p>替换为另一个布局时，必须为新布局建立绑定。 因此，ViewStubProxy必须监听ViewStub的ViewStub.OnInflateListener并在那时建立绑定。 由于只有一个可以存在，ViewStubProxy允许开发人员设置一个OnInflateListener，它将在建立绑定后调用。</p>
<h3 id="高级绑定"><a href="#高级绑定" class="headerlink" title="高级绑定"></a>高级绑定</h3><h4 id="动态变量"><a href="#动态变量" class="headerlink" title="动态变量"></a>动态变量</h4><p>有时候，不知道一些特殊的绑定类。例如，对任意布局的RecyclerView.Adapter不会知道特定的绑定类。 它仍然必须在onBindViewHolder（VH，int）期间分配绑定值。</p>
<p>在这个例子中，所有绑定的条目都有一个变量，BindingHolder拥有一个getBinding方法返回ViewDataBinding。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void onBindViewHolder(BindingHolder holder, int position) &#123;</span><br><span class="line">   final T item = mItems.get(position);</span><br><span class="line">   holder.getBinding().setVariable(BR.item, item);</span><br><span class="line">   holder.getBinding().executePendingBindings();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="立即绑定"><a href="#立即绑定" class="headerlink" title="立即绑定"></a>立即绑定</h4><p>当variable或者Observable发生变化时，绑定将会在下一帧改变，但是有时候必须立即执行，此时需要调用xecutePendingBindings（）方法。</p>
<h4 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h4><p>您可以在后台线程中更改数据模型，只要它不是集合即可。 数据绑定将本地化每个变量/字段，同时评估以避免任何并发问题。</p>
<h2 id="属性设置"><a href="#属性设置" class="headerlink" title="属性设置"></a>属性设置</h2><p>每当绑定值更改时，生成的绑定类必须在具有绑定表达式的视图上调用setter方法。 数据绑定框架有自定义哪个方法来调用以设置值的方法。</p>
<h3 id="Automatic-Setters"><a href="#Automatic-Setters" class="headerlink" title="Automatic Setters"></a>Automatic Setters</h3><p>对于一个属性来说，DataBinding视图查找设置该属性的方法，属性的命名空间无关紧要，只有属性本身有关系。例如：TextView的android:text属性会查找setText(String)方法。如果表达式返回一个int值，则DataBinding会查找setText(int)方法。在表达式返回的类型这件事上要特别小心，如果需要请使用强制转换。注意，DataBinding在被给定的属性不存在时仍会工作。你可以轻松的创建任何属性。例如。DrawerLayout没有任何属性，你可以使用自动创建setter方法设置如下属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;android.support.v4.widget.DrawerLayout</span><br><span class="line">    android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    app:scrimColor=&quot;@&#123;@color/scrim&#125;&quot;</span><br><span class="line">    app:drawerListener=&quot;@&#123;fragment.drawerListener&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="重命名setter"><a href="#重命名setter" class="headerlink" title="重命名setter"></a>重命名setter</h3><p>一些属性的setter名不符实，你可以通过BindingMethods注解与setter关联。这必须与一个类相关联，并包含BindingMethods注解。例如，android：tint属性确实与setImageTintList（ColorStateList）相关联，而不是setTint。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@BindingMethods(&#123;</span><br><span class="line">       @BindingMethod(type = &quot;android.widget.ImageView&quot;,</span><br><span class="line">                      attribute = &quot;android:tint&quot;,</span><br><span class="line">                      method = &quot;setImageTintList&quot;),</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>开发者不必去重命名setters，安卓框架会完成这些工作。</p>
<h3 id="自定义setters"><a href="#自定义setters" class="headerlink" title="自定义setters"></a>自定义setters</h3><p>一些属性需要自定义绑定的逻辑，例如：系统没有为android：paddingLeft属性的关联setter。 相反，setPadding（left，top，right，bottom）存在。 使用BindingAdapter注释的静态绑定适配器方法允许开发人员自定义如何调用属性的setter。<br>安卓属性已经创建了BindingAdapters。例如，这是PaddingLeft：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@BindingAdapter(&quot;android:paddingLeft&quot;)</span><br><span class="line">public static void setPaddingLeft(View view, int padding) &#123;</span><br><span class="line">   view.setPadding(padding,</span><br><span class="line">                   view.getPaddingTop(),</span><br><span class="line">                   view.getPaddingRight(),</span><br><span class="line">                   view.getPaddingBottom());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Binding Adapter在其他类型的自定义非常有用。例如，自定义加载器可以称为离线加载图像。</p>
<p>当发生冲突时，开发人员创建的绑定适配器将覆盖数据绑定的默认适配器。</p>
<p>你也可以利用adapter接收多个参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@BindingAdapter(&#123;&quot;bind:imageUrl&quot;, &quot;bind:error&quot;&#125;)</span><br><span class="line">public static void loadImage(ImageView view, String url, Drawable error) &#123;</span><br><span class="line">   Picasso.with(view.getContext()).load(url).error(error).into(view);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;ImageView app:imageUrl=&quot;@&#123;venue.imageUrl&#125;&quot;</span><br><span class="line">app:error=&quot;@&#123;@drawable/venueError&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>在imageview使用iamgeurl这个字符串或者是error这个图片</p>
<ul>
<li>命名空间在匹配期间会自动被忽略</li>
<li>你也可以为命名空间写一个adapter</li>
</ul>
<p>Binding Adapter方法可以可选地在其处理程序中使用旧值。 使用旧值和新值的方法应该具有属性的所有旧值，然后是新值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@BindingAdapter(&quot;android:paddingLeft&quot;)</span><br><span class="line">public static void setPaddingLeft(View view, int oldPadding, int newPadding) &#123;</span><br><span class="line">   if (oldPadding != newPadding) &#123;</span><br><span class="line">       view.setPadding(newPadding,</span><br><span class="line">                       view.getPaddingTop(),</span><br><span class="line">                       view.getPaddingRight(),</span><br><span class="line">                       view.getPaddingBottom());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>事件传递仅在继承接口或者抽象类的情况下使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@BindingAdapter(&quot;android:onLayoutChange&quot;)</span><br><span class="line">public static void setOnLayoutChangeListener(View view, View.OnLayoutChangeListener oldValue,</span><br><span class="line">       View.OnLayoutChangeListener newValue) &#123;</span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class="line">        if (oldValue != null) &#123;</span><br><span class="line">            view.removeOnLayoutChangeListener(oldValue);</span><br><span class="line">        &#125;</span><br><span class="line">        if (newValue != null) &#123;</span><br><span class="line">            view.addOnLayoutChangeListener(newValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当一个监听器拥有多个方法时，也必须分割为与之对应的监听器。例如，View.OnAttachStateChangeListener有两个方法: onViewAttachedToWindow()和onViewDetachedFromWindow()。我们必须创建两个接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@TargetApi(VERSION_CODES.HONEYCOMB_MR1)</span><br><span class="line">public interface OnViewDetachedFromWindow &#123;</span><br><span class="line">    void onViewDetachedFromWindow(View v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@TargetApi(VERSION_CODES.HONEYCOMB_MR1)</span><br><span class="line">public interface OnViewAttachedToWindow &#123;</span><br><span class="line">    void onViewAttachedToWindow(View v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于改变其中的一个监听器会影响另一个，所以必须创建三个不同的binding Adapter，每个属性一个外加一个为两个属性关联的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">@BindingAdapter(&quot;android:onViewAttachedToWindow&quot;)</span><br><span class="line">public static void setListener(View view, OnViewAttachedToWindow attached) &#123;</span><br><span class="line">    setListener(view, null, attached);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@BindingAdapter(&quot;android:onViewDetachedFromWindow&quot;)</span><br><span class="line">public static void setListener(View view, OnViewDetachedFromWindow detached) &#123;</span><br><span class="line">    setListener(view, detached, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@BindingAdapter(&#123;&quot;android:onViewDetachedFromWindow&quot;, &quot;android:onViewAttachedToWindow&quot;&#125;)</span><br><span class="line">public static void setListener(View view, final OnViewDetachedFromWindow detach,</span><br><span class="line">        final OnViewAttachedToWindow attach) &#123;</span><br><span class="line">    if (VERSION.SDK_INT &gt;= VERSION_CODES.HONEYCOMB_MR1) &#123;</span><br><span class="line">        final OnAttachStateChangeListener newListener;</span><br><span class="line">        if (detach == null &amp;&amp; attach == null) &#123;</span><br><span class="line">            newListener = null;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            newListener = new OnAttachStateChangeListener() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void onViewAttachedToWindow(View v) &#123;</span><br><span class="line">                    if (attach != null) &#123;</span><br><span class="line">                        attach.onViewAttachedToWindow(v);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public void onViewDetachedFromWindow(View v) &#123;</span><br><span class="line">                    if (detach != null) &#123;</span><br><span class="line">                        detach.onViewDetachedFromWindow(v);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        final OnAttachStateChangeListener oldListener = ListenerUtil.trackListener(view,</span><br><span class="line">                newListener, R.id.onAttachStateChangeListener);</span><br><span class="line">        if (oldListener != null) &#123;</span><br><span class="line">            view.removeOnAttachStateChangeListener(oldListener);</span><br><span class="line">        &#125;</span><br><span class="line">        if (newListener != null) &#123;</span><br><span class="line">            view.addOnAttachStateChangeListener(newListener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子比正常情况稍微复杂一些，因为View使用add和remove作为监听器，而不是View.OnAttachStateChangeListener的set方法。 android.databinding.adapters.ListenerUtil类可以帮助跟踪以前的监听器，以便它们可以在绑定Adaper中删除。</p>
<p>通过使用@TargetApi（VERSION_CODES.HONEYCOMB_MR1）注释接口OnViewDetachedFromWindow和OnViewAttachedToWindow，数据绑定代码生成器知道监听器应该只在运行于Honeycomb MR1和新设备（由addOnAttachStateChangeListener（View.OnAttachStateChangeListener）支持的相同版本）上时生成。</p>
<h2 id="转换器"><a href="#转换器" class="headerlink" title="转换器"></a>转换器</h2><h3 id="对象转换"><a href="#对象转换" class="headerlink" title="对象转换"></a>对象转换</h3><p>当一个对象从绑定表达式中返回时，一个setter方法会被选择–automatic（自动）, renamed（重命名）, 和custom（自定义） setters。对象会被转换为选择的setter的参数。</p>
<p>这对于使用ObservableMaps来保存数据的人来说很方便。 例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextView</span><br><span class="line">   android:text=&apos;@&#123;userMap[&quot;lastName&quot;]&#125;&apos;</span><br><span class="line">   android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">   android:layout_height=&quot;wrap_content&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>userMap返回一个在setText(CharSequence)方法中转换出来的值，当参数的类型有歧义时，开发者需要在表达式中强制转换。</p>
<h3 id="自定义转换"><a href="#自定义转换" class="headerlink" title="自定义转换"></a>自定义转换</h3><p>有时候转换器应该自动转换数据类型。例如在设置背景时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;View</span><br><span class="line">   android:background=&quot;@&#123;isError ? @color/red : @color/white&#125;&quot;</span><br><span class="line">   android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">   android:layout_height=&quot;wrap_content&quot;/&gt;</span><br></pre></td></tr></table></figure></p>
<p>背景应该是一个Drawable，但是color是int型。无论何时，都应该是一个drawable，int应该转换为colorDrawable。使用一个带 BindingConversion注解的静态方法可以完成这个转换：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@BindingConversion</span><br><span class="line">public static ColorDrawable convertColorToDrawable(int color) &#123;</span><br><span class="line">   return new ColorDrawable(color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note:转换器只在setter时有作用，千万不要混合使用两种类型：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;View</span><br><span class="line">   android:background=&quot;@&#123;isError ? @drawable/error : @color/white&#125;&quot;</span><br><span class="line">   android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">   android:layout_height=&quot;wrap_content&quot;/&gt;</span><br></pre></td></tr></table></figure>
<h3 id="AndroidStudio支持的DataBinding"><a href="#AndroidStudio支持的DataBinding" class="headerlink" title="AndroidStudio支持的DataBinding"></a>AndroidStudio支持的DataBinding</h3><p>Android Studio支持许多用于数据绑定代码的代码编辑功能。例如，它支持数据绑定表达式的以下功能：</p>
<ul>
<li>语法高亮显示</li>
<li>标记表达式语言语法错误</li>
<li>XML代码自动补全</li>
<li>引用，包括导航（如导航到声明）和快速文档</li>
</ul>
<blockquote>
<p>Note：数组和泛型类型（如Observable类）可能在没有错误时显示错误。</p>
</blockquote>
<p>“预览”窗格显示数据绑定表达式的默认值（如果提供）。在以下示例中，从布局XML文件中截取元素，“预览”窗格在TextView中显示PLACEHOLDER默认文本值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextView android：layout_width =“wrap_content”</span><br><span class="line">   android：layout_height =“wrap_content”</span><br><span class="line">   android：text =“@ &#123;user.firstName，default = PLACEHOLDER&#125;”/&gt;</span><br></pre></td></tr></table></figure>
<p>如果需要在项目的设计阶段显示默认值，还可以使用工具属性而不是默认表达式值，如Designtime布局属性中所述。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/DataBinding/" rel="tag"># DataBinding</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/02/01/（译）MaterialDesign（八）-Transformimg/" rel="next" title="（译）MaterialDesign（八）-Transformimg">
                <i class="fa fa-chevron-left"></i> （译）MaterialDesign（八）-Transformimg
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/02/02/（译）MaterialDesign（九）-Choreography/" rel="prev" title="（译）MaterialDesign（九）-Choreography">
                （译）MaterialDesign（九）-Choreography <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://ok7v12rvl.bkt.clouddn.com/01b18.jpg"
               alt="rangaofei" />
          <p class="site-author-name" itemprop="name">rangaofei</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">55</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories/">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags/">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Databinding-库"><span class="nav-number">1.</span> <span class="nav-text">Databinding 库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#构建环境"><span class="nav-number">1.1.</span> <span class="nav-text">构建环境</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DataBinding的布局文件"><span class="nav-number">1.2.</span> <span class="nav-text">DataBinding的布局文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编写你的第一个DataBinding表达式"><span class="nav-number">1.2.1.</span> <span class="nav-text">编写你的第一个DataBinding表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据对象"><span class="nav-number">1.2.2.</span> <span class="nav-text">数据对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#绑定数据"><span class="nav-number">1.2.3.</span> <span class="nav-text">绑定数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#传递事件"><span class="nav-number">1.2.4.</span> <span class="nav-text">传递事件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#方法引用"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">方法引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#监听绑定"><span class="nav-number">1.2.4.2.</span> <span class="nav-text">监听绑定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#避免使用复杂的监听器"><span class="nav-number">1.2.4.3.</span> <span class="nav-text">避免使用复杂的监听器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#布局细节"><span class="nav-number">1.3.</span> <span class="nav-text">布局细节</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#变量"><span class="nav-number">1.3.1.</span> <span class="nav-text">变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义绑定类的名称"><span class="nav-number">1.3.2.</span> <span class="nav-text">自定义绑定类的名称</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Includes标签"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">Includes标签</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#表达式语言"><span class="nav-number">1.3.3.</span> <span class="nav-text">表达式语言</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#常用特性"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">常用特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#不支持的操作"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">不支持的操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#空合并运算-Null-Coalescing-Operator-—不知道怎么翻译"><span class="nav-number">1.3.3.3.</span> <span class="nav-text">空合并运算(Null Coalescing Operator)—不知道怎么翻译</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#属性引用"><span class="nav-number">1.3.3.4.</span> <span class="nav-text">属性引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#避免空指针异常"><span class="nav-number">1.3.3.5.</span> <span class="nav-text">避免空指针异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#集合"><span class="nav-number">1.3.3.6.</span> <span class="nav-text">集合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符串"><span class="nav-number">1.3.3.7.</span> <span class="nav-text">字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#资源文件"><span class="nav-number">1.3.3.8.</span> <span class="nav-text">资源文件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据对象-1"><span class="nav-number">1.4.</span> <span class="nav-text">数据对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ObservableFields"><span class="nav-number">1.4.1.</span> <span class="nav-text">ObservableFields</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Observable-Collections"><span class="nav-number">1.4.2.</span> <span class="nav-text">Observable Collections</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建绑定文件"><span class="nav-number">1.5.</span> <span class="nav-text">创建绑定文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建"><span class="nav-number">1.5.1.</span> <span class="nav-text">创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#带Id的Views"><span class="nav-number">1.5.2.</span> <span class="nav-text">带Id的Views</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#变量-1"><span class="nav-number">1.5.3.</span> <span class="nav-text">变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ViewStubs（这篇不常用，-而且文档介绍较少）"><span class="nav-number">1.5.4.</span> <span class="nav-text">ViewStubs（这篇不常用， 而且文档介绍较少）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#高级绑定"><span class="nav-number">1.5.5.</span> <span class="nav-text">高级绑定</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#动态变量"><span class="nav-number">1.5.5.1.</span> <span class="nav-text">动态变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#立即绑定"><span class="nav-number">1.5.5.2.</span> <span class="nav-text">立即绑定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#后台线程"><span class="nav-number">1.5.5.3.</span> <span class="nav-text">后台线程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#属性设置"><span class="nav-number">1.6.</span> <span class="nav-text">属性设置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Automatic-Setters"><span class="nav-number">1.6.1.</span> <span class="nav-text">Automatic Setters</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重命名setter"><span class="nav-number">1.6.2.</span> <span class="nav-text">重命名setter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义setters"><span class="nav-number">1.6.3.</span> <span class="nav-text">自定义setters</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#转换器"><span class="nav-number">1.7.</span> <span class="nav-text">转换器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#对象转换"><span class="nav-number">1.7.1.</span> <span class="nav-text">对象转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义转换"><span class="nav-number">1.7.2.</span> <span class="nav-text">自定义转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AndroidStudio支持的DataBinding"><span class="nav-number">1.7.3.</span> <span class="nav-text">AndroidStudio支持的DataBinding</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rangaofei</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  

  
      <!-- UY BEGIN -->
      <script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid="></script>
      <!-- UY END -->
  




  
  

  

  

  

  


</body>
</html>
